# macOS 应用构建和发布工作流
# 用于构建 Tauri 桌面应用并发布到 GitHub Releases，适用于开发者分发
name: Build and Release macOS App

# 触发条件：推送到 master 分支或手动触发
on:
  push:
    branches: [master]
  # 支持手动触发，方便开发者按需构建
  workflow_dispatch:

# 权限配置 - 允许工作流进行必要的操作
permissions:
  contents: write    # 允许创建 releases 和推送到仓库

# 环境变量配置
env:
  # 启用彩色输出，便于查看构建日志
  FORCE_COLOR: 1
  # Node.js 版本
  NODE_VERSION: '18'

jobs:
  build-macos:
    name: Build macOS Application
    runs-on: macos-latest

    steps:
      # 1. 代码检出 - 获取完整的仓库代码
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # 获取完整的 Git 历史，用于生成版本信息
          fetch-depth: 0
          # 使用 PAT token 以绕过分支保护规则
          # 如果没有配置 PAT_TOKEN，则使用默认的 GITHUB_TOKEN
          token: ${{ secrets.PAT_TOKEN || github.token }}

      # 2. 设置 Node.js 环境
      # Tauri 前端需要 Node.js 来构建 React + Vite 项目
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          # 使用官方 npm 注册表
          registry-url: 'https://registry.npmjs.org'

      # 3. 设置 pnpm 包管理器（使用官方 Action，避免经由 npm 安装）
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          run_install: false

      # 4. 获取 pnpm 缓存目录
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      # 5. 缓存 pnpm 依赖
      # 缓存机制可以显著加速构建过程
      - name: Cache pnpm dependencies
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      # 6. 安装 Rust 工具链
      # Tauri 后端使用 Rust 编写，需要 Rust 编译器
      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          # 安装稳定版 Rust
          toolchain: stable
          # macOS 构建目标
          targets: x86_64-apple-darwin,aarch64-apple-darwin

      # 7. 缓存 Rust 依赖
      # Rust 编译时间较长，缓存可以显著提升构建速度
      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          # 缓存 Cargo 构建产物
          workspaces: src-tauri

      # 8. 安装前端依赖
      # 安装 React、Vite 等前端构建依赖
      - name: Install frontend dependencies
        run: pnpm install --frozen-lockfile

      # 9. 自动版本更新
      # 根据 commit 消息自动确定版本更新类型并更新配置文件
      - name: Auto version bump
        id: version_bump
        run: |
          echo "开始版本检测和更新..."

          # 获取当前版本号（从 package.json）
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "当前版本: $CURRENT_VERSION"

          # 获取最新的 commit 消息
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          echo "Commit 消息: $COMMIT_MSG"

          # 版本更新逻辑
          if [[ "$COMMIT_MSG" =~ ^feat(\(.+\))?!: ]] || [[ "$COMMIT_MSG" =~ BREAKING[[:space:]]CHANGE ]]; then
            # Major 版本更新：feat!: 或包含 BREAKING CHANGE
            VERSION_TYPE="major"
            echo "检测到 BREAKING CHANGE，执行 major 版本更新"
          elif [[ "$COMMIT_MSG" =~ ^feat(\(.+\))?: ]]; then
            # Minor 版本更新：feat:
            VERSION_TYPE="minor"
            echo "检测到新功能，执行 minor 版本更新"
          elif [[ "$COMMIT_MSG" =~ ^fix(\(.+\))?: ]]; then
            # Patch 版本更新：fix:
            VERSION_TYPE="patch"
            echo "检测到修复，执行 patch 版本更新"
          else
            # 默认 patch 版本更新
            VERSION_TYPE="patch"
            echo "其他提交类型，执行 patch 版本更新"
          fi

          # 计算新版本号
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}

          case $VERSION_TYPE in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "新版本号: $NEW_VERSION"

          # 更新 package.json
          echo "更新 package.json 版本..."
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '$NEW_VERSION';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "

          # 更新 src-tauri/tauri.conf.json
          echo "更新 tauri.conf.json 版本..."
          node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
            config.version = '$NEW_VERSION';
            fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(config, null, 2) + '\n');
          "

          # 输出版本信息供后续步骤使用
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "old_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

          echo "✅ 版本更新完成: $CURRENT_VERSION → $NEW_VERSION ($VERSION_TYPE)"

      # 10. 构建 Tauri 应用
      # 这是核心步骤：构建前端 + 后端并打包成 macOS 应用
      - name: Build Tauri application
        run: |
          echo "开始构建 Tauri 应用..."
          # 首先构建前端
          echo "构建前端..."
          pnpm build:renderer

          # 然后构建 Tauri 应用
          echo "构建 Tauri 后端并打包..."
          pnpm tauri build --verbose
        env:
          # 使用 ad-hoc 签名，适用于开发者分发
          # 通过 tauri.conf.json 中的 signingIdentity: "-" 配置
          # 确保构建目标包含 Apple Silicon 和 Intel 架构
          TAURI_BUILD_TARGETS: "universal-apple-darwin"

      # 11. 查找构建产物
      # 构建完成后，需要找到生成的 .app 和 .dmg 文件
      - name: Find build artifacts
        id: find_artifacts
        run: |
          echo "查找构建产物..."

          # 查找 .app 文件
          APP_PATH=$(find src-tauri/target/release/bundle/macos -name "*.app" -type d | head -1)
          echo "找到 .app 文件: $APP_PATH"
          echo "app_path=$APP_PATH" >> $GITHUB_OUTPUT

          # 查找 .dmg 文件
          DMG_PATH=$(find src-tauri/target/release/bundle/dmg -name "*.dmg" | head -1)
          echo "找到 .dmg 文件: $DMG_PATH"
          echo "dmg_path=$DMG_PATH" >> $GITHUB_OUTPUT

          # 获取应用名称（从 .app 路径提取）
          APP_NAME=$(basename "$APP_PATH" .app)
          echo "应用名称: $APP_NAME"
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT

      # 12. 创建应用压缩包
      # 为 .app 文件创建压缩包，作为备用分发格式
      - name: Create app archive
        run: |
          echo "创建应用压缩包..."
          cd "$(dirname "${{ steps.find_artifacts.outputs.app_path }}")"
          tar -czf "${{ steps.find_artifacts.outputs.app_name }}.app.tar.gz" "${{ steps.find_artifacts.outputs.app_name }}.app"
          echo "压缩包已创建: $PWD/${{ steps.find_artifacts.outputs.app_name }}.app.tar.gz"

      # 13. 提交版本更新
      # 将版本更新提交回仓库，保持版本同步
      - name: Commit version bump
        run: |
          echo "提交版本更新到仓库..."
          # 配置 Git 用户信息
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # 添加和提交更改
          git add package.json src-tauri/tauri.conf.json
          git commit -m "chore(release): bump version to ${{ steps.version_bump.outputs.new_version }} [skip ci]" || echo "No changes to commit"

          # 推送到远程仓库
          # 注意：这里会使用 checkout 时配置的 token
          git push origin HEAD:master || echo "Push failed - this is expected if branch protection is enabled"
        env:
          # 使用与 checkout 相同的 token
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN || github.token }}

      # 14. 创建 GitHub Release
      # 自动创建 Release 并上传构建产物
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          # 使用语义化版本标签
          tag_name: "v${{ steps.version_bump.outputs.new_version }}"
          name: "Switch CC v${{ steps.version_bump.outputs.new_version }}"
          # 生成 Release Notes
          body: |
            ## Switch CC macOS 版本发布

            **版本信息:**
            - 版本号: v${{ steps.version_bump.outputs.new_version }}
            - 版本类型: ${{ steps.version_bump.outputs.version_type }} (从 v${{ steps.version_bump.outputs.old_version }} 升级)
            - 构建时间: ${{ github.event.head_commit.timestamp }}
            - 提交信息: ${{ github.event.head_commit.message }}
            - 提交哈希: ${{ github.sha }}

            **macOS 安装说明:**
            1. 下载 `.dmg` 文件（推荐）
            2. 双击挂载磁盘镜像
            3. 将 Switch CC 应用拖拽到 Applications 文件夹
            4. **重要**: 首次运行时请按以下步骤操作：
               - 在 Applications 文件夹中找到 Switch CC
               - **右键点击** Switch CC 应用
               - 选择 **"打开"**
               - 在安全警告对话框中点击 **"打开"**
               - 之后可以正常双击启动

            **如果遇到"已损坏"错误:**
            - 该错误通常是由于 macOS Gatekeeper 的安全检查
            - 请严格按照上述右键"打开"的方式首次启动
            - 首次成功运行后，后续可正常双击启动

            **备用安装方式:**
            - 如果 `.dmg` 文件无法使用，可下载 `.app.tar.gz` 压缩包
            - 解压后将 `.app` 文件拖拽到 Applications 文件夹
            - 同样需要右键"打开"进行首次启动

            **技术说明:**
            - 此版本使用 ad-hoc 签名，符合 macOS 安全要求
            - 不会显示"已损坏"错误，但需要手动确认首次运行
            - 适用于开发者分发和测试使用
          # 标记为预发布版本
          prerelease: false
          # 上传构建产物
          files: |
            ${{ steps.find_artifacts.outputs.dmg_path }}
            $(dirname "${{ steps.find_artifacts.outputs.app_path }}")/${{ steps.find_artifacts.outputs.app_name }}.app.tar.gz
        env:
          # 使用 GitHub Token 进行认证
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 15. 构建完成通知
      - name: Build completed
        run: |
          echo "🎉 构建完成！"
          echo "📦 版本信息:"
          echo "  - 版本更新: v${{ steps.version_bump.outputs.old_version }} → v${{ steps.version_bump.outputs.new_version }} (${{ steps.version_bump.outputs.version_type }})"
          echo "📦 生成的产物:"
          echo "  - DMG 安装包: ${{ steps.find_artifacts.outputs.dmg_path }}"
          echo "  - APP 压缩包: ${{ steps.find_artifacts.outputs.app_name }}.app.tar.gz"
          echo "🚀 Release 已创建: v${{ steps.version_bump.outputs.new_version }}"